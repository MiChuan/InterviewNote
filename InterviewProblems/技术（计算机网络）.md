## 计算机网络

### OSI七层模型、TCP/IP四层模型、五层协议

- **OSI七层模型：** 应用层、（表示层、会话层）、传输层、网络层、（数据链路层、物理层）。
- **TCP/IP四层模型：** 应用层、传输层、网络层、网络接口层。
- **五层体系结构：** 应用层、传输层（段）、网络层（包）、数据链路层（帧）、物理层（比特流）。

### 网络协议

- 应用层：HTTP，FTP，SMTP，DNS，SSH，DHCP，TELNET
- 传输层：TCP，UDP
- 网络层：IP，ARP，ICMP，IGMP，RIP，OSPF，BGP

### TCP为什么需要3次握手？

- 三次握手过程
  - 刚开始客户端处于closed（关闭）的状态，服务端处于 listen（监听） 状态。然后
  - 第一次握手：客户端给服务端发一个 **SYN 报文段**，并指明客户端的初始化序列号 **ISN(c)**。此时客户端处于 **SYN_Send** （同步已发送）状态。
  - 第二次握手：服务器收到客户端的 SYN 报文之后，为该TCP连接分配TCP缓存和变量，以 **SYNACK 报文段**作为应答，指定了自己的初始化序列号 **ISN(s)**，把客户端的 **ISN(c) + 1** 作为确认号，表示已收到了客户端的SYN报文段，此时服务器处于 **SYN_RCVD** （同步收到）的状态。
  - 第三次握手：客户端收到 **SYNACK 报文段**之后，为该TCP连接分配TCP缓存和变量，发送一个 ACK 报文，把服务器的**ISN(s) + 1**作为确认号，表示已经收到了服务端的SYNACK报文段，此时客户端处于 **established** （已建立连接）状态。服务器收到 ACK 报文之后，也处于 **established** 状态，此时，双方建立起了链接

- 为什么需要三次握手？
  - 为了防止客户端A已失效的链接请求发送到服务端B时，引起的服务端B资源浪费。如A发出的连接请求由于种种原因延迟了，失效了，但过了一段时间B收到了，若只用2次握手，B此时决定建立连接。但此连接是已失效的，B在等待A数据过程中，浪费了资源。

![img](http://mi_chuan.gitee.io/blog/三次握手.png) 

### TCP为什么需要4次挥手？

- 四次挥手过程
  - 开始客户端、服务端处于established的状态
  - 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1（终止等待状态1）。
  - 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的确认号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT（关闭等待）状态。此时TCP连接处于半关闭状态，客户端到服务端没有数据发送，而服务端到客户端可以继续发送数据。客户端收到服务端的确认报文段，进入FIN_WAIT2（终止等待状态2），等待服务端发送释放连接报文。
  - 第三次挥手：服务端数据发送完毕，发 FIN ACK报文，且指定一个序列号。此时服务端处于 LAST_ACK （最后确认）的状态。
  - 第四次挥手：客户端收到FIN ACK报文 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的确认号值，此时客户端处于 TIME_WAIT 状态。需要等待2MSL以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

- 为什么需要TIME_WAIT ？
  - 保证客户端发送的最后一个确认报文到达服务端，如果丢失，可以在服务端等待超时重传FIN报文，客户端接收到FIN报文后重传确认报文。
  - 使本次连接过程中产生的所有报文段从网络中消失，防止已失效的连接请求报文出现。

![img](http://mi_chuan.gitee.io/blog/四次挥手.png)

### TCP状态

LISTEN – 侦听来自远方TCP端口的连接请求；

SYN-SENT -在发送连接请求后等待匹配的连接请求；

SYN-RECEIVED – 在收到和发送一个连接请求后等待对连接请求的确认；

ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；

FIN-WAIT-1 – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

FIN-WAIT-2 – 从远程TCP等待连接中断请求；

CLOSE-WAIT – 等待从本地用户发来的连接中断请求；

CLOSING -等待远程TCP对连接中断的确认；

LAST-ACK – 等待原来发向远程TCP的连接中断请求的确认；

TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；

CLOSED – 没有任何连接状态；

### TCP和UDP有什么区别？

- **用户数据报协议UDP:** 无连接；尽最大可能交付；无拥塞控制；支持一对一、一对多、多对一、多对多；应用:视频通信、实时通信。
- **传输控制协议TCP:** 面向连接；提供可靠交付；有流量控制、拥塞控制；提供全双工通信，面向字节流；每条TCP连接只能点对点。应用:邮件传输，文件传输，HTTP。

### TCP如何保证传输的可靠性？

1. 数据包校验
2. 对失序数据包重新排序（TCP报文具有序列号）
3. 丢弃重复数据
4. 确认机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
5. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

### TCP的流量控制？

- 流量控制是为了控制发送方的发送速率，保证接收方来得及接收；
- 接收方维护一个接收窗口，大小根据资源情况动态调整，接收方发送的确认报文中的窗口字段可用来控制发送方的发送窗口大小，从而影响发送方的发送速率。
- 发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。

### TCP拥塞控制？

- 四种算法：慢启动、拥塞避免、快重传、快恢复。
  - **慢启动：** （拥塞窗口）cwnd = 1, cwnd = 2 * cwnd。
  - **拥塞避免：** 当cwnd >= ssthresh（慢启动阀值）时进入，cwnd = cwnd + 1；如果出现超时，则ssthresh = cwnd / 2，然后重新执行慢开始。
  - **快重传：** 发送方收到三个重复确认，可以知道此确认的下一个报文段丢失，执行快重传，例如连续收到三个M2，则M3丢失，立即重传M3。
  - **快恢复：** 将拥塞阈值降低为拥塞窗口的一半，将cwnd设置为ssthresh，此时直接进入拥塞避免。

### IP地址的分类？

路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。

### DNS 的解析过程？

- 主机向本地域名服务器的查询一般都是采用递归查询。递归查询：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。
- 本地域名服务器向根域名服务器的迭代查询。迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。

### 什么叫划分子网？

从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。

### 子网掩码作用？

- 测量多个 IP 是否在同一网段的工具；
- 例如 IP -192.168.1.199，子网掩码-255.255.255.0，则可以得到此IP地址的网络号为192.168.1，主机号为199。

### ARP是地址解析协议，简单语言解释一下工作原理。

每台主机或路由器在其内存中具有一个ARP表（ARP table）,这张表包含IP地址到MAC地址的映射关系。将IP地址通过广播，根据目标IP地址解析到MAC地址。

### ICMP 有哪些应用？

**1. Ping**

Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

**2. Traceroute**

Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。

Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

### IPV4 地址不够如何解决？

- NAT
- IPv6：2 的 128 次方个地址

### 什么是NAT (Network Address Translation, 网络地址转换)？

用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。

### 什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？

每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。

### DHCP协议？

- 客户机请求IP；（客户机发DHCPDISCOVER广播包）
- 服务器响应；（服务器发DHCPOFFER广播包）
- 客户机选择IP；（客户机发DHCPREQUEST广播包）
- 服务器确定租约。（服务器发DHCPACK/DHCPNAK广播包）

### 从输入网址到获得页面的过程 (越详细越好)？

1. 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；
2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；
3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

### HTTP1.0，1.1，2.0版本区别？

- HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。
- HTTP/1.1引入持久连接。持久连接即TCP连接默认不关闭，可以被多个请求复用。HTTP/1.1引入管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。
- HTTP/2 采用了多路复用。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了二进制分帧，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。

### HTTP的长连接和短连接？

- HTTP/1.0默认使用短链接，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束中断连接。每遇到新Web资源（如JS、CSS、图像等），就要新建立一个HTTP会话，这样浪费额外资源。
- HTTP/1.1开始默认使用长连接，保持连接特性。当打开一个网页后，客户端和服务期间用于传输HTTP数据的TCP连接不会关闭。
- HTTP协议长连接和短链接，实质上是TCP协议的长连接和短链接。

### Session与Cookie的区别？

- 存储位置不同：Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案

- 存储容量不同：单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie。对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。
- 存储方式不同：cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。
- 隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。session存储在服务器上，对客户端透明，不存在敏感信息泄漏的风险。
- 有效期上不同：开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。
- 服务器压力不同：cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。

### 简述GET和POST的区别？

- Get 多用于无副作用，幂等的场景；Post 多用于副作用，不幂等的场景；GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；
- 缓存：GET请求可被缓存、收藏、保留到历史记录。POST多数情况下不可缓存；
- 请求形式上：GET请求数据附在URL后面，在HTTP请求头中，而POST在HTTP请求体内；
- GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；

### HTTPS 的工作过程？

1、 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；

2、 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的颁发机构；

3、客户端收到网站的证书之后要做下面的事情：

- 验证证书的合法性；
- 如果验证通过证书，浏览器会生成一串随机数作为对称密钥，并用证书中的公钥进行加密；
- 用约定好的 hash 算法计算握手消息，然后用生成的对称密钥进行加密，然后一起发送给服务器。

4、服务器接收到客户端传送来的信息，要做下面的事情：

- 4.1 用私钥解析出对称密钥，用对称密钥解析握手消息，验证 hash 值是否和浏览器发来的一致；
- 4.2 使用对称密钥加密消息；

5、如果计算法 hash 值一致，握手成功。

### HTTP和HTTPS有什么区别？

1. 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
2. HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；
3. HTTPS由于加密解密会带来更大的CPU和内存开销；
4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买

### HTTP请求有哪些常见状态码？

- 1xx：表示目前是协议的中间状态，还需要后续请求。101 切换请求协议，从 HTTP 切换到 WebSocket。
- 2xx：操作成功。200 请求成功，有响应体。
- 3xx：重定向。301 永久重定向；302暂时重定向
- 4xx：客户端错误。400 请求错误；401 未授权；403 服务器禁止访问；404 资源未找到；
- 5xx：服务端错误。500服务器内部错误；501服务不可用；503 服务器繁忙

### HTTP 方法有哪些？

1. GET：获取资源，当前网络中绝大部分使用的都是 GET；
2. HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；
3. POST：传输实体主体
4. PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。
5. PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。
6. OPTIONS：查询指定的 URL 支持的方法；
7. CONNECT：要求与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
8. TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。
9. Delete：删除文件,与 PUT 功能相反，并且同样不带验证机制。

### 什么是SQL 注入？举个例子？

把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

## 参考资料

### 网址

[计算机网络常见面试题](https://krahets.gitee.io/views/computer-network/2019-09-18-post-computer-network-interview.html#%E7%AE%80%E8%BF%B0get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F)

[计算机基础知识](https://github.com/wolverinn/Waking-Up)

[计算机网络面试题-帅地玩编程](https://www.iamshuaidi.com/interview-netword)

### 书籍

计算机网络 - 谢希仁

计算机网络自顶向下